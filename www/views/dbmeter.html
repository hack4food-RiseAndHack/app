<ion-view view-title="Browse">
  <ion-content>
    script>
    var width = 400;
    var height = 600;

    // create a renderer instance
    var renderer = PIXI.autoDetectRenderer(width, height, {
        backgroundColor: 0x1099bb
    });
    document.body.appendChild(renderer.view);

    // create the root of the scene graph
    var stage = new PIXI.Container();

    requestAnimFrame(animate);

    var a = new Image('spine1.png');
    console.log("timage: ", a);

    var spine1_r_texture = PIXI.Texture.fromImage("spine1.png");
    var spine1_l_texture = PIXI.Texture.fromImage("spine2.png");

    var spine1_r = new PIXI.Sprite(spine1_r_texture);
    var spine1_l = new PIXI.Sprite(spine1_l_texture);

    var spine2_r_texture = PIXI.Texture.fromImage("spine1.png");
    var spine2_l_texture = PIXI.Texture.fromImage("spine2.png");

    var spine2_r = new PIXI.Sprite(spine2_r_texture);
    var spine2_l = new PIXI.Sprite(spine2_l_texture);

    var balloon_texture = PIXI.Texture.fromImage("balloon.png");
    var balloon = new PIXI.Sprite(balloon_texture);


    console.log("Balloon ", balloon);

    // create a text object that will be updated...
    var debug_text = new PIXI.Text('debug text');

    debug_text.position.x = 50;
    debug_text.position.y = 0;
    debug_text.anchor.x = 0.5;

    balloon.position.x = 75;
    balloon.position.y = 300;
    balloon.scale.x -= 0.5;
    balloon.scale.y -= 0.5;

    var spine1_start = height / 2 + (height * (-1));
    var spine2_start = height / 5 + (height * (-1));

    spine1_r.position.x = 300;
    spine1_r.position.y = spine1_start;
    spine1_r.scale.x -= 0.5;
    spine1_r.scale.y -= 0.5;

    spine1_l.position.x = -150;
    spine1_l.position.y = spine1_start;
    spine1_l.scale.x -= 0.5;
    spine1_l.scale.y -= 0.5;

    spine2_r.position.x = 300;
    spine2_r.position.y = spine2_start;
    spine2_r.scale.x -= 0.5;
    spine2_r.scale.y -= 0.5;

    spine2_l.position.x = -150;
    spine2_l.position.y = spine2_start;
    spine2_l.scale.x -= 0.5;
    spine2_l.scale.y -= 0.5;

    var renderTexture = new PIXI.RenderTexture(renderer, 800, 600);
var sprite = PIXI.Sprite.fromImage("spine1.png");

sprite.position.x = 800/2;
sprite.position.y = 600/2;
sprite.anchor.x = 0.5;
sprite.anchor.y = 0.5;

console.log("canvas: ", renderTexture.render(sprite));




    stage.addChild(balloon);

    stage.addChild(spine1_r);
    stage.addChild(spine1_l);

    stage.addChild(spine2_r);
    stage.addChild(spine2_l);
    //stage.addChild(spine2);

    stage.addChild(debug_text);

    function animate() {

        requestAnimFrame(animate);
        

        spine1_r.position.y += 1.5;
        spine1_l.position.y += 1.5;


        if (spine1_r.position.y > height) {
            spine1_r.position.y = spine1_start;
            spine1_l.position.y = spine1_start;
        }



        spine2_r.position.y += 1.5;
        spine2_l.position.y += 1.5;

        if (spine2_r.position.y > height) {
            spine2_r.position.y = spine2_start;
            spine2_l.position.y = spine2_start;
            debug_text.text = "debug";
        }







        // just for fun, lets rotate mr rabbit a little
        //bunny.rotation += 0.1;
        //if (bunny.position.x > 400) bunny.position.x = -10;
        //bunny.position.x += 0.5;

        //bunny.scale.x += 0.3;
        //bunny.scale.y += 0.3;


        // render the stage   
        renderer.render(stage);
    }


    /**
     * @author Joseph Lenton - PlayMyCode.com
     *
     * @param first An ImageData object from the first image we are colliding with.
     * @param x The x location of 'first'.
     * @param y The y location of 'first'.
     * @param other An ImageData object from the second image involved in the collision check.
     * @param x2 The x location of 'other'.
     * @param y2 The y location of 'other'.
     * @param isCentred True if the locations refer to the centre of 'first' and 'other', false to specify the top left corner.
     */
    function isPixelCollision(first, x, y, other, x2, y2, isCentred) {
        // we need to avoid using floats, as were doing array lookups
        x = Math.round(x);
        y = Math.round(y);
        x2 = Math.round(x2);
        y2 = Math.round(y2);

        var w = first.width,
            h = first.height,
            w2 = other.width,
            h2 = other.height;

        // deal with the image being centred
        if (isCentred) {
            // fast rounding, but positive only
            x -= (w / 2 + 0.5) << 0
            y -= (h / 2 + 0.5) << 0
            x2 -= (w2 / 2 + 0.5) << 0
            y2 -= (h2 / 2 + 0.5) << 0
        }

        // find the top left and bottom right corners of overlapping area
        var xMin = Math.max(x, x2),
            yMin = Math.max(y, y2),
            xMax = Math.min(x + w, x2 + w2),
            yMax = Math.min(y + h, y2 + h2);

        // Sanity collision check, we ensure that the top-left corner is both
        // above and to the left of the bottom-right corner.
        if (xMin >= xMax || yMin >= yMax) {
            return false;
        }

        var xDiff = xMax - xMin,
            yDiff = yMax - yMin;

        // get the pixels out from the images
        var pixels = first.data,
            pixels2 = other.data;

        // if the area is really small,
        // then just perform a normal image collision check
        if (xDiff < 4 && yDiff < 4) {
            for (var pixelX = xMin; pixelX < xMax; pixelX++) {
                for (var pixelY = yMin; pixelY < yMax; pixelY++) {
                    if (
                        (pixels[((pixelX - x) + (pixelY - y) * w) * 4 + 3] !== 0) &&
                        (pixels2[((pixelX - x2) + (pixelY - y2) * w2) * 4 + 3] !== 0)
                    ) {
                        return true;
                    }
                }
            }
        } else {
            /* What is this doing?
             * It is iterating over the overlapping area,
             * across the x then y the,
             * checking if the pixels are on top of this.
             *
             * What is special is that it increments by incX or incY,
             * allowing it to quickly jump across the image in large increments
             * rather then slowly going pixel by pixel.
             *
             * This makes it more likely to find a colliding pixel early.
             */

            // Work out the increments,
            // it's a third, but ensure we don't get a tiny
            // slither of an area for the last iteration (using fast ceil).
            var incX = xDiff / 3.0,
                incY = yDiff / 3.0;
            incX = (~~incX === incX) ? incX : (incX + 1 | 0);
            incY = (~~incY === incY) ? incY : (incY + 1 | 0);

            for (var offsetY = 0; offsetY < incY; offsetY++) {
                for (var offsetX = 0; offsetX < incX; offsetX++) {
                    for (var pixelY = yMin + offsetY; pixelY < yMax; pixelY += incY) {
                        for (var pixelX = xMin + offsetX; pixelX < xMax; pixelX += incX) {
                            if (
                                (pixels[((pixelX - x) + (pixelY - y) * w) * 4 + 3] !== 0) &&
                                (pixels2[((pixelX - x2) + (pixelY - y2) * w2) * 4 + 3] !== 0)
                            ) {
                                return true;
                            }
                        }
                    }
                }
            }
        }

        return false;
    }
    </script>
  </ion-content>
</ion-view>
